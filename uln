#!/bin/bash
## uln ::

print_help() {
cat <<'HELPDOC'
NAME
    uln - link or copy multiple files at once

SYNOPSIS
    uln <COMMAND> [OPTION...]

DESCRIPTION
    Uln is symbolic link creator and/or file copier controlled via config file.
    Uln reads a .uln file in the current directory and executes COMMAND.

COMMANDS
    init
        Create new .uln file in current directory.

    link
        Create symbolic links defined in .uln file.

    copy
        Copy files defined in .uln file.

OPTIONS
    -c, --config <FILE>
        Read config from FILE instead of .uln default.

    -D, --dry-run
        Perform trial run making no changes.

    -H, --help
        Display this help.

FILES
    .uln - yaml file containing following keys:

        dir
            Directory to create symbolic links in or copy files to. Required.

        targets
            List of target files relative to current directory.

HOSTNAME
    The file linked/copied may be dependent upon HOSTNAME by appending
    _HOSTNAME to filename. For example, if FILE.EXT is in targets, a link to
    FILE_HOSTNAME.EXT will be created, if it exists, instead of FILE.EXT.

REQUIRES
    yq
HELPDOC
}

# TODO: add option to select between absolute/relative links
# TODO: list/query action

## internal control ::
a=0
arg="$1"
args=("$@")
arr_config=()
dir=
file_config='.uln'
file_path=
flg_copy=false
flg_dryrun=false
flg_init=false
flg_link=false
host="$HOSTNAME"
n_actions=0
opt_config=
requirements=(rsync ssh yq)
tdir=
tname=
tpath=
target=
targets=()

if [ -f /etc/hostname- ]; then
    host="$(</etc/hostname-)"
elif [ -f /etc/hostname ]; then
    host="$(</etc/hostname)"
fi

## functions ::
msg() {
    printf "\e[1;38;5;12m==> \e[0;38;5;15m$1\e[0m\n" "${@:2}"
}

msg_error() {
    printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_warn() {
    printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_cmd() {
    local ps1=$'\e[1;38;5;10m'' :$'
    [ $EUID -eq 0 ] && ps1=$'\e[1;38;5;9m'' :#'
    printf '%s \e[0;38;5;15m%s\n' "$ps1" "$(printf '%q ' "$@")"
}

msg2_error() {
    printf "\e[1;38;5;9m -> \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

## main ::
while [ -n "$arg" ]; do case "$arg" in
    init)
        flg_init=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    link)
        flg_link=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    copy)
        flg_copy=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    -c|--config)
        [ $# -le $((a+1)) ] && msg_error "arg required: $arg" && exit 3
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -D|--dryrun)
        flg_dryrun=true; arg="${args[((++a))]}" ;;
    -H|--help)
        print_help; exit 0 ;;
    -[DH]*)
        if [[ ! "${arg:2:1}" =~ [DHc] ]]; then
            msg_error "unknown option: ${arg:2:1}"; exit 3
        fi
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*)
        args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --)
        ((a++)); break ;;
    *)
        break ;;
esac; done
args=("${args[@]:a}")

for req in "${requirements[@]}"; do if ! command -v "$req" &>/dev/null; then
    msg_error 'required: %s' "$req"
    exit 4
fi; done

if [ ${#args[@]} -gt 0 ]; then
    msg_error "unknown args: ${args[*]}"
    exit 3
fi

if [ $n_actions -eq 0 ] || [ $n_actions -gt 1 ]; then
    msg_error 'too many/no actions given'
    exit 3
fi

file_config="${opt_config:-$file_config}"

if [ "$flg_init" = true ]; then
    if [ -f "$file_config" ]; then
        msg_error '%q already exists' "$file_config"
        exit 3
    fi
    touch "$file_config"
    { printf '## %s ::\n\n' "$(realpath "$file_config")"
    printf 'dir: %s\n\ntargets:\n\n# vim:ft=yaml\n' "$HOME" ;} > "$file_config"
    exit 0
fi

if [ ! -f "$file_config" ]; then
    msg_error "file not found: $file_config"
    exit 3
fi

mapfile -t arr_config < <(yq -r '.dir, .targets[]' 2>/dev/null "$file_config")
if [ ${#arr_config[@]} -lt 1 ]; then
    msg_error "yaml error: $file_config"
    exit 3
fi
dir="${arr_config[0]}"; [ "$dir" = 'null' ] && dir=
targets=("${arr_config[@]:1}")

if [ -z "$dir" ]; then
    msg_error 'no directory'
    exit 3
fi

[ "${dir:0:1}" = '~' ] && dir="$HOME${dir:1}"
[ "${dir: -1}" = '/' ] && dir="${dir:0:-1}"

for target in "${targets[@]}"; do
    [ "${target: -1}" = '/' ] && target="${target:0:-1}"
    fpath="$dir/$target"
    tpath="$PWD/$target"
    tdir="${tpath%/*}"
    tname="${tpath##*/}"

    if [[ "${tname:1}" =~ '.' ]] && [ -e "$tdir/${tname%.*}_$host.${tname##*.}" ]; then
        tname="${tname%.*}_$host.${tname##*.}"
    elif [ -e "$tdir/$tname_$host" ]; then
        tname="$tname_$host"
    fi
    tpath="$tdir/$tname"
    [ ! -e "$tpath" ] && continue

    if [ "$flg_link" = true ]; then
        if [ ! -h "$fpath" ] || [ "$(readlink "$fpath")" != "$tpath" ]; then
            if [ "$flg_dryrun" = false ]; then
                if mkdir -p "${fpath%/*}" &>/dev/null &&
                rm -rf "$fpath" &>/dev/null &&
                ln -sf "$tpath" "$fpath" &>/dev/null; then
                    msg_cmd ln -sf "$tpath" "$fpath"
                else
                    msg2_error "cannot write: $fpath"
                fi
            else
                msg_cmd ln -sf "$tpath" "$fpath"
            fi
        fi

    elif [ "$flg_copy" = true ]; then
        # TODO: cmp here instead of diff?
        if [ ! -e "$fpath" ] ||
        ! diff -rq --no-dereference "$fpath" "$tpath" &>/dev/null; then
            if [ "$flg_dryrun" = false ]; then
                if mkdir -p "${fpath%/*}" &>/dev/null &&
                rm -rf "$fpath" &>/dev/null &&
                cp -r "$tpath" "$fpath" &>/dev/null; then
                    msg_cmd cp -r "$tpath" "$fpath"
                else
                    msg2_error "cannot write: $fpath"
                fi
            else
                msg_cmd cp -r "$tpath" "$fpath"
            fi
        fi
    fi
done

[ "$flg_dryrun" = true ] && msg_warn 'dry-run: no files changed'

# vim:ft=bash
