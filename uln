#!/bin/bash
## uln ::

print_help() { cat <<'HELPDOC'
NAME
    uln - link or copy multiple files at once

SYNOPSIS
    uln <COMMAND> [OPTION...]

DESCRIPTION
    Uln is symbolic link creator and/or file copier controlled via config file.
    Uln reads a .uln file in the current directory.

COMMANDS
    init
        Create new .uln file in current directory.

    link
        Create symbolic links defined in .uln file.

    copy
        Copy files defined in .uln file.

OPTIONS
    -c, --config <FILE>
        Read config from FILE instead of .uln default.

    -D, --dry-run
        Perform trial run making no changes.

    -H, --help
        Display this help.

FILES
    .uln - yaml file containing following keys:

        dest
            Link/copy destination directory. (required)

        srcs
            List of source files. (required)

HOSTNAME
    The file linked/copied may be dependent upon HOSTNAME by appending
    _HOSTNAME to filename.

    For example, if FILE.EXT is in srcs and a FILE_HOSTNAME.EXT exists, uln
    will link/copy that file instead of FILE.EXT.
HELPDOC
}

# TODO: add option to select between absolute/relative links
# TODO: --debug option

## control ::
dest=
dpath=
conf='.uln'
host="$HOSTNAME"
line=
lines=()
n_cmds=0
opt_config=
sdir=
sname=
spath=
src=
srcs=()
in_src=false

# args:
a=0 arg="$1" args=("$@")
flg_copy=false
flg_dryrun=false
flg_init=false
flg_link=false

## functions ::
is_cmd() { command -v "$1" &>/dev/null ;}
msg() { printf "\e[1;38;5;12m=> \e[0;38;5;15m$1\e[0m\n" "${@:2}" ;}
msg2() { printf '\e[1;38;5;12m > \e[0;38;5;15m%s\e[0m\n' "$*" ;}
msg_cmd() { printf '\e[1;38;5;12m $\e[0;38;5;15m'; printf ' %q' "$@"; printf '\n' ;}
[ $EUID -eq 0 ] && msg_cmd() { printf '\e[1;38;5;9m $\e[0;38;5;15m'; printf ' %q' "$@"; printf '\n' ;}
msg_error() { printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}
msg_warn() { printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}
error() { msg_error "$@"; exit 5 ;}

## main ::
while [ -n "$arg" ]; do case "$arg" in
    init) flg_init=true; arg="${args[((++a))]}"; ((n_cmds++)) ;;
    link) flg_link=true; arg="${args[((++a))]}"; ((n_cmds++)) ;;
    copy) flg_copy=true; arg="${args[((++a))]}"; ((n_cmds++)) ;;
    -D|--dryrun) flg_dryrun=true; arg="${args[((++a))]}" ;;
    -H|--help) print_help; exit 0 ;;
    -c|--config)
        [ $# -le $((a+1)) ] && error "arg required: $arg"
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -[DH]*)
        [[ ! "${arg:2:1}" =~ [DHc] ]] && error "unknown option: ${arg:2:1}"
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*) args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --) ((a++)); break ;;
    *) break ;;
esac; done
args=("${args[@]:a}")

# args error:
[ ${#args[@]} -gt 0 ] && error "unknown args: ${args[*]}"
[ $n_cmds -eq 0 ] && msg_warn 'no command' && exit 9
[ $n_cmds -gt 1 ] && error 'too many commands'

# set config file from command line option:
conf="${opt_config:-$conf}"

if [ "$flg_init" = true ]; then
    # create new .uln file in current directory:
    [ -f "$conf" ] && error "$conf already exists"
    touch "$conf"
    { printf '## %s ::\n\n' "$(realpath "$conf")"
    printf 'dest: %s\n\nsrcs:\n\n# vim:ft=yaml\n' "$HOME" ;} > "$conf"
    exit 0
fi

# config file not found:
[ ! -f "$conf" ] && error "config not found: $conf"

# parse config:
mapfile -t lines < <(sed -E -e 's/(^\s+|\s+$)//g' -e '/^(#|$|-$)/d' "$conf")
in_src=false
for line in "${lines[@]}"; do
    if [ "$in_src" = true ]; then
        [[ "$line" =~ ^-\ +(.*) ]] && srcs+=("${BASH_REMATCH[1]}") && continue
        in_src=false
    fi
    [[ "$line" =~ ^dest:\ +(.*) ]] && dest="${BASH_REMATCH[1]}" && continue
    [ "$line" = 'srcs:' ] && in_src=true && continue
done
[ "${dest:0:1}" = '~' ] && dest="$HOME${dest:1}"
[ "${dest: -1}" = '/' ] && dest="${dest:0:-1}"

# no destination directory:
[ -z "$dest" ] && error 'no destination directory'

# resolve host:
[ -f '/etc/hostname' ] && host="$(cat /etc/hostname)"
[ -f '/etc/hostname-' ] && host="$(cat /etc/hostname-)"

for src in "${srcs[@]}"; do
    # TODO: check if any src contains any src:
    # remove trailing slash from src file/dir:
    [ "${src: -1}" = '/' ] && src="${src:0:-1}"

    # set destination path:
    dpath="$dest/$src"

    # set src destination directory and name:
    spath="$PWD/$src"
    sdir="${spath%/*}"
    sname="${spath##*/}"

    # change src name if a src file with _HOSTNAME appended exists:
    if [[ "${sname:1}" =~ '.' ]] && [ -e "$sdir/${sname%.*}_$host.${sname##*.}" ]; then
        sname="${sname%.*}_$host.${sname##*.}"
    elif [ -e "$sdir/${sname}_$host" ]; then
        sname="${sname}_$host"
    fi

    # set and check src path:
    spath="$sdir/$sname"
    [ ! -e "$spath" ] && continue

    # create link to src file:
    if [ "$flg_link" = true ]; then
        # destination is not a symlink or it's pointing to the wrong src:
        if [ ! -h "$dpath" ] || [ "$(readlink "$dpath")" != "$spath" ]; then
            [ "$flg_dryrun" = true ] && msg_cmd ln -sf "$spath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # create link:
            ln -sf "$spath" "$dpath" &>/dev/null; then
                msg_cmd ln -sf "$spath" "$dpath"
            else
                msg_error "unable to create link: $dpath"
            fi
        fi

    # copy src file:
    elif [ "$flg_copy" = true ]; then
        # destination file doesn't exist or it's different from src file:
        if ! diff -rq --no-dereference "$dpath" "$spath" &>/dev/null; then
            [ "$flg_dryrun" = true ] && msg_cmd cp -r "$spath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # copy file/directory:
            cp -r "$spath" "$dpath" &>/dev/null; then
                msg_cmd cp -r "$spath" "$dpath"
            else
                msg_error "unable to create copy: $dpath"
            fi
        fi
    fi
done

# vim:ft=bash
