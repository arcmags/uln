#!/bin/bash
## uln ::

print_help() {
cat <<'HELPDOC'
NAME
    uln - link or copy multiple files at once

SYNOPSIS
    uln <COMMAND> [OPTION...]

DESCRIPTION
    Uln is symbolic link creator and/or file copier controlled via config file.
    Uln reads a .uln file in the current directory.

COMMANDS
    init
        Create new .uln file in current directory.

    link
        Create symbolic links defined in .uln file.

    copy
        Copy files defined in .uln file.

OPTIONS
    -c, --config <FILE>
        Read config from FILE instead of .uln default.

    -D, --dry-run
        Perform trial run making no changes.

    -H, --help
        Display this help.

FILES
    .uln - strict-yaml file containing following keys:

        dest
            Link/copy destination directory. Required.

        srcs
            Source files.

HOSTNAME
    The file linked/copied may be dependent upon HOSTNAME by appending
    _HOSTNAME to filename. For example, if FILE.EXT is in srcs, a link to
    FILE_HOSTNAME.EXT will be created, if it exists, instead of FILE.EXT.
HELPDOC
}

# TODO: add option to select between absolute/relative links
# TODO: list/query action

## internal control ::
a=0
arg="$1"
args=("$@")
arr_config=()
dest=
dpath=
file_config='.uln'
file_path=
flg_copy=false
flg_dryrun=false
flg_init=false
flg_link=false
flg_srcs=false
host="$HOSTNAME"
line=
lines=
n_acts=0
opt_config=
sdir=
sname=
spath=
src=
srcs=()

if [ -f /etc/hostname- ]; then
    host="$(</etc/hostname-)"
elif [ -f /etc/hostname ]; then
    host="$(</etc/hostname)"
fi

## functions ::
msg() {
    printf "\e[1;38;5;12m=> \e[0;38;5;15m$1\e[0m\n" "${@:2}"
}

msg_error() {
    printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_warn() {
    printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_cmd() {
    local ps1=$'\e[1;38;5;10m'' $'
    [ $EUID -eq 0 ] && ps1=$'\e[1;38;5;9m'' #'
    [ "$flg_dryrun" = true ] && ps1=$'\e[1;38;5;11m'" ${ps1: -1}"
    printf '%s \e[0;38;5;15m%s\e[0m\n' "$ps1" "$(printf '%q ' "$@")"
}

## main ::
while [ -n "$arg" ]; do case "$arg" in
    init)
        flg_init=true; arg="${args[((++a))]}"; ((n_acts++)) ;;
    link)
        flg_link=true; arg="${args[((++a))]}"; ((n_acts++)) ;;
    copy)
        flg_copy=true; arg="${args[((++a))]}"; ((n_acts++)) ;;
    -c|--config)
        [ $# -le $((a+1)) ] && msg_error "arg required: $arg" && exit 3
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -D|--dryrun)
        flg_dryrun=true; arg="${args[((++a))]}" ;;
    -H|--help)
        print_help; exit 0 ;;
    -[DH]*)
        if [[ ! "${arg:2:1}" =~ [DHc] ]]; then
            msg_error "unknown option: ${arg:2:1}"; exit 3
        fi
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*)
        args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --)
        ((a++)); break ;;
    *)
        break ;;
esac; done
args=("${args[@]:a}")

# unknown args/action:
if [ ${#args[@]} -gt 0 ]; then
    msg_error "unknown args: ${args[*]}"
    exit 3
fi

# no action/too many actions:
if [ $n_acts -eq 0 ]; then
    msg_warn 'no action'
    exit 0
elif [ $n_acts -gt 1 ]; then
    msg_error 'too many actions'
    exit 3
fi

# set config file from command line option:
file_config="${opt_config:-$file_config}"

if [ "$flg_init" = true ]; then
    # create new .uln file in current directory:
    if [ -f "$file_config" ]; then
        msg_error '%q already exists' "$file_config"
        exit 3
    fi
    touch "$file_config"
    { printf '## %s ::\n\n' "$(realpath "$file_config")"
    printf 'dest: %s\n\nsrcs:\n\n# vim:ft=yaml\n' "$HOME" ;} > "$file_config"
    exit 0
fi

# config not found:
if [ ! -f "$file_config" ]; then
    msg_error "config not found: $file_config"
    exit 3
fi

# parse config:
mapfile -t lines < <(sed -E -e 's/(^\s+|\s+$)//g' -e '/^(#|$|-$)/d' "$file_config")
flg_srcs=false
for line in "${lines[@]}"; do
    if [ "$flg_srcs" = true ]; then
        [[ "$line" =~ ^-\ +(.*) ]] && srcs+=("${BASH_REMATCH[1]}") && continue
        flg_srcs=false
    fi
    [[ "$line" =~ ^dest:\ +(.*) ]] && dest="${BASH_REMATCH[1]}" && continue
    [ "$line" = 'srcs:' ] && flg_srcs=true && continue
done

# no destination directory:
if [ -z "$dest" ]; then
    msg_error 'no destination directory'
    exit 3
fi

# substitute leading ~ in destination directory with $HOME:
[ "${dest:0:1}" = '~' ] && dest="$HOME${dest:1}"

# remove trailing slash from destination directory:
[ "${dest: -1}" = '/' ] && dest="${dest:0:-1}"

for src in "${srcs[@]}"; do
    # TODO: need to check if any src contains any src:

    # remove trailing slash from src file/dir:
    [ "${src: -1}" = '/' ] && src="${src:0:-1}"

    # set destination path:
    dpath="$dest/$src"

    # set src destination directory and name:
    spath="$PWD/$src"
    sdir="${spath%/*}"
    sname="${spath##*/}"

    # change src name if a src file with _HOSTNAME appended exists:
    if [[ "${sname:1}" =~ '.' ]] && [ -e "$sdir/${sname%.*}_$host.${sname##*.}" ]; then
        sname="${sname%.*}_$host.${sname##*.}"
    elif [ -e "$sdir/${sname}_$host" ]; then
        sname="${sname}_$host"
    fi

    # set and check src path:
    spath="$sdir/$sname"
    [ ! -e "$spath" ] && continue

    # create link to src file:
    if [ "$flg_link" = true ]; then
        # destination is not a symlink or it's pointing to the wrong src:
        if [ ! -h "$dpath" ] || [ "$(readlink "$dpath")" != "$spath" ]; then
            [ "$flg_dryrun" = true ] && msg_cmd ln -sf "$spath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # create link:
            ln -sf "$spath" "$dpath" &>/dev/null; then
                msg_cmd ln -sf "$spath" "$dpath"
            else
                msg_error "unable to create link: $dpath"
            fi
        fi

    # copy src file:
    elif [ "$flg_copy" = true ]; then
        # destination file doesn't exist or it's different from src file:
        if ! diff -rq --no-dereference "$dpath" "$spath" &>/dev/null; then
            [ "$flg_dryrun" = true ] && msg_cmd cp -r "$spath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # copy file/directory:
            cp -r "$spath" "$dpath" &>/dev/null; then
                msg_cmd cp -r "$spath" "$dpath"
            else
                msg_error "unable to create copy: $dpath"
            fi
        fi
    fi
done

# vim:ft=bash
