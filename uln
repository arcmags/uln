#!/bin/bash
## uln ::

print_help() {
cat <<'HELPDOC'
NAME
    uln - link or copy multiple files at once

SYNOPSIS
    uln <COMMAND> [OPTION...]

DESCRIPTION
    Uln is symbolic link creator and/or file copier controlled via config file.
    Uln reads a .uln file in the current directory and executes COMMAND.

COMMANDS
    init
        Create new .uln file in current directory.

    link
        Create symbolic links defined in .uln file.

    copy
        Copy files defined in .uln file.

OPTIONS
    -c, --config <FILE>
        Read config from FILE instead of .uln default.

    -D, --dry-run
        Perform trial run making no changes.

    -H, --help
        Display this help.

FILES
    .uln - yaml file containing following keys:

        dir
            Directory to create symbolic links in or copy files to. Required.

        targets
            List of target files relative to current directory.

HOSTNAME
    The file linked/copied may be dependent upon HOSTNAME by appending
    _HOSTNAME to filename. For example, if FILE.EXT is in targets, a link to
    FILE_HOSTNAME.EXT will be created, if it exists, instead of FILE.EXT.

REQUIRES
    yq
HELPDOC
}

# TODO: add option to select between absolute/relative links
# TODO: list/query action
# TODO: drop yq dependency
# TODO: more messages?

## internal control ::
a=0
arg="$1"
args=("$@")
arr_config=()
dir=
file_config='.uln'
file_path=
flg_copy=false
flg_dryrun=false
flg_init=false
flg_link=false
host="$HOSTNAME"
n_actions=0
opt_config=
requirements=(rsync ssh yq)
tdir=
tname=
tpath=
target=
targets=()

if [ -f /etc/hostname- ]; then
    host="$(</etc/hostname-)"
elif [ -f /etc/hostname ]; then
    host="$(</etc/hostname)"
fi

## functions ::
msg() {
    printf "\e[1;38;5;12m=> \e[0;38;5;15m$1\e[0m\n" "${@:2}"
}

msg_error() {
    printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_warn() {
    printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_cmd() {
    local ps1=$'\e[1;38;5;10m'' $'
    [ $EUID -eq 0 ] && ps1=$'\e[1;38;5;9m'' #'
    [ "$flg_dryrun" = true ] && ps1=$'\e[1;38;5;11m'" ${ps1: -1}"
    printf '%s \e[0;38;5;15m%s\e[0m\n' "$ps1" "$(printf '%q ' "$@")"
}

## main ::
while [ -n "$arg" ]; do case "$arg" in
    init)
        flg_init=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    link)
        flg_link=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    copy)
        flg_copy=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    -c|--config)
        [ $# -le $((a+1)) ] && msg_error "arg required: $arg" && exit 3
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -D|--dryrun)
        flg_dryrun=true; arg="${args[((++a))]}" ;;
    -H|--help)
        print_help; exit 0 ;;
    -[DH]*)
        if [[ ! "${arg:2:1}" =~ [DHc] ]]; then
            msg_error "unknown option: ${arg:2:1}"; exit 3
        fi
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*)
        args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --)
        ((a++)); break ;;
    *)
        break ;;
esac; done
args=("${args[@]:a}")

# missing requirements:
for req in "${requirements[@]}"; do if ! command -v "$req" &>/dev/null; then
    msg_error 'missing requirement: %s' "$req"
    exit 4
fi; done

# unknown args/action:
if [ ${#args[@]} -gt 0 ]; then
    msg_error "unknown args: ${args[*]}"
    exit 3
fi

# no action/too many actions:
if [ $n_actions -eq 0 ]; then
    msg_warn 'no action'
    exit 0
elif [ $n_actions -gt 1 ]; then
    msg_error 'too many actions'
    exit 3
fi

# set config file from command line option:
file_config="${opt_config:-$file_config}"

if [ "$flg_init" = true ]; then
    # create new .uln file in current directory:
    if [ -f "$file_config" ]; then
        msg_error '%q already exists' "$file_config"
        exit 3
    fi
    touch "$file_config"
    { printf '## %s ::\n\n' "$(realpath "$file_config")"
    printf 'dir: %s\n\ntargets:\n\n# vim:ft=yaml\n' "$HOME" ;} > "$file_config"
    exit 0
fi

# config not found:
if [ ! -f "$file_config" ]; then
    msg_error "config not found: $file_config"
    exit 3
fi

# parse config with yq, get dir and targets[]:
mapfile -t arr_config < <(yq -r '.dir//"", .targets[]//""' 2>/dev/null "$file_config")
if [ ${#arr_config[@]} -lt 1 ]; then
    msg_error "yaml error: $file_config"
    exit 3
fi
dir="${arr_config[0]}"
targets=("${arr_config[@]:1}")

# no destination directory:
if [ -z "$dir" ]; then
    msg_error 'no destination directory'
    exit 3
fi

# substitute leading ~ in destination directory with $HOME:
[ "${dir:0:1}" = '~' ] && dir="$HOME${dir:1}"

# remove trailing slash from destination directory:
[ "${dir: -1}" = '/' ] && dir="${dir:0:-1}"

for target in "${targets[@]}"; do
    # TODO: need to check if any targets contain any targets:

    # remove trailing slash from target file/dir:
    [ "${target: -1}" = '/' ] && target="${target:0:-1}"

    # set destination path:
    dpath="$dir/$target"

    # set target destination directory and name:
    tpath="$PWD/$target"
    tdir="${tpath%/*}"
    tname="${tpath##*/}"

    # change target name if a target file with _HOSTNAME appended exists:
    if [[ "${tname:1}" =~ '.' ]] && [ -e "$tdir/${tname%.*}_$host.${tname##*.}" ]; then
        tname="${tname%.*}_$host.${tname##*.}"
    elif [ -e "$tdir/${tname}_$host" ]; then
        tname="${tname}_$host"
    fi

    # set and check target path:
    tpath="$tdir/$tname"
    [ ! -e "$tpath" ] && continue

    # create link to target file:
    if [ "$flg_link" = true ]; then
        # destination is not a symlink or it's pointing to the wrong target:
        if [ ! -h "$dpath" ] || [ "$(readlink "$dpath")" != "$tpath" ]; then
            [ "$flg_dryrun" = true ] && msg_cmd ln -sf "$tpath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # create link:
            ln -sf "$tpath" "$dpath" &>/dev/null; then
                msg_cmd ln -sf "$tpath" "$dpath"
            else
                msg_error "unable to create link: $dpath"
            fi
        fi

    # copy target file:
    elif [ "$flg_copy" = true ]; then
        # destination file doesn't exist or it's different from target file:
        if ! diff -rq --no-dereference "$dpath" "$tpath" &>/dev/null; then
            [ "$flg_dryrun" = true ] && msg_cmd cp -r "$tpath" "$dpath" && continue
            # create parent directories:
            if mkdir -p "${dpath%/*}" &>/dev/null &&
            # remove previous file:
            rm -rf "$dpath" &>/dev/null &&
            # copy file/directory:
            cp -r "$tpath" "$dpath" &>/dev/null; then
                msg_cmd cp -r "$tpath" "$dpath"
            else
                msg_error "unable to create copy: $dpath"
            fi
        fi
    fi
done

# vim:ft=bash
